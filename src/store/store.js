// We need to import the variables declared in firebase.js
import { firebaseAuth, firebaseDb } from "boot/firebase"
import Vue from 'vue'
import { boot } from "quasar/wrappers"

let messageRef

const state = {
    // Store user datails for the application
    userDetails : {},
    users: {},
    // state that holds the message
    messages: {}
}

const mutations = {
    // User details need a mutation
    setUserDetails(state, payload) {
        state.userDetails = payload
    },
    addUser(state, payload) {
        // We need to use Vue here, otherwise we vue won't know about the data
        Vue.set(state.users, payload.userId, payload.userDetails)
    },
    updateUser(state, payload) {
        // Called from firebaseGetUsers for each user
        Object.assign(state.users[payload.userId], payload.userDetails)
    },
    addMessage(state, payload) {
        Vue.set(state.message, payload.messageId, payload.messageDetails)
    },
    clearMessages(state) {
        state.messages = {}
    }
}

const actions = {
    // Payload is the data passed in via LoginRegister.vue component
    registerUser({}, payload) {
        firebaseAuth.createUserWithEmailAndPassword(payload.email, payload.password)
        .then(response => {
            // Success
            console.log(response)
            // Recover the id generated by firebase, we will use it in our
            // table.
            let userId = firebaseAuth.currentUser.uid
            // This part adds the user to our users table in the database
            // this is not on the auth system.
            firebaseDb.ref('users/' + userId).set({
                name: payload.name,
                email: payload.email,
                online: true
            })
        })
        .catch(error => {
            console.log(error.message)
        })
    },
    loginUser({}, payload) {
        firebaseAuth.signInWithEmailAndPassword(payload.email, payload.password)
        .then(response => {
            // Success
           console.log("User logged in!")
        })
        .catch(error => {
            console.log(error.message)
        })
    },
    logoutUser() {
        firebaseAuth.signOut()
    },
    handleAuthStateChanged({ commit, dispatch, state }) {
        // This is a firebase hook
        firebaseAuth.onAuthStateChanged(user => {
        if (user) {
            // LOGGED IN
            // User is logged in.
            // Get a ref to the firebase aut
            let userId = firebaseAuth.currentUser.uid
            // We only want to get this once when the user logs in
            firebaseDb.ref('users/' + userId).once('value', snapshot => {
                let userDetails = snapshot.val()
                // Commit the mutation
                commit('setUserDetails', {
                    // set payload
                    name: userDetails.name,
                    email: userDetails.email,
                    userId: userId
                })
                // Set online to true
                dispatch('firebaseUpdateUser', {
                    // payload to send to firebase.
                    // In sql this would translate to UPDATE Users SET online=True WHERE UserId=UserId
                    userId: userId,
                    updates: {
                        online: true
                    }
                })
                // Get all the users in the database
                dispatch('firebaseGetUsers')
                // This is a response.redirect
                this.$router.push('/').catch((err) => {
                    console.log("Error snapped in router push (store.js)")
                })
            })
        } else {  
            // LOGGED OUT 
            // This is a response.redirect
            // First clear the history so the user can't go back
            dispatch('firebaseUpdateUser', {
                    // We need to add state to the signature of the method above,
                    // because we can't access the userDetails otherwise
                    userId: state.userDetails.userId,
                    updates: {
                        online: false
                    }
                })
            // The user is logged out
            // reset the login must be executed after dispatch otherwise 
            // userDetails object is empty!
            commit('setUserDetails', {})
            this.$router.replace('/auth')
        }
        });
    },
    firebaseUpdateUser({}, payload) {
        // setup a ref
        firebaseDb.ref('users/' + payload.userId).update(payload.updates)
    },
    firebaseGetUsers({ commit }) {
        // get a ref to the database and then get the app users from the database
        firebaseDb.ref('users/').on('child_added', snapshot => {
            // This code is executed when a new child node (json) is added from the users table
            let userDetails = snapshot.val()
            // To get the user id we need to go back to the snapshot itself.  Because,
            // snapshot.val only has the fields belonging to it.
            let userId = snapshot.key
            // create a mutation
            commit('addUser', {
                // Payload
                userId,
                userDetails
            })
        })
        firebaseDb.ref('users/').on('child_changed', snapshot => {
            // This is where the magic happens, if firebase is updated (some logs in our out),
            // this hook will be executed.
            let userDetails = snapshot.val()
            // To get the user id we need to go back to the snapshot itself.  Because,
            // snapshot.val only has the fields belonging to it.
            let userId = snapshot.key
            // create a mutation
            commit('updateUser', {
                // Payload
                userId,
                userDetails
            })
        })
    },
    firebaseGetMessages({ commit, state }, otherUserId) {
        let userId = state.userDetails.userId
        messageRef = firebaseDb.ref('chat/' + userId + '/' + otherUserId)
        messageRef.on('child_added', snapshot => {
            let messageDetails = snapshot.val()
            let messageId = snapshot.key
            // Mutate
            commit('addMessage', {
                // Payload holding the messages
                messageId,
                messageDetails
            })
        })
    },
    firebaseStopGettingMessages( { commit }) {
        // Must call this to stop the firebaseGetMessages hool
        console.log('Leaving page')
        if (messageRef) {
            // turn off
            messageRef.off('child_added')
            commit('clearMessages')
        }
    }
}

const getters = {
    // This getter is needed to get our data in the users form
    users: state => {
        // Get all users, but exclude ourselves
        let usersFiltered = {}
        Object.keys(state.users).forEach(key => {
            // Is this me?
            if (key !== state.userDetails.userId) {
                usersFiltered[key] = state.users[key]
            }
        })
        return usersFiltered
    }
}

export default {
    namespaced: true,
    state,
    mutations,
    actions,
    getters
}